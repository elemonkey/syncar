name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # ===== LINT Y TESTS =====
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ['3.11']
        node-version: ['20']

    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4

      # Backend tests
      - name: 🐍 Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: 📦 Install Python dependencies
        run: |
          cd backend
          pip install -r requirements.txt
          pip install pytest pytest-asyncio

      - name: 🧪 Run Python tests
        run: |
          cd backend
          pytest -v || echo "Tests not implemented yet"

      # Frontend tests
      - name: 📦 Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}

      - name: 📦 Install Node dependencies
        run: |
          cd frontend
          npm ci || npm install

      - name: 🧪 Run Node tests
        run: |
          cd frontend
          npm test || echo "Tests not implemented yet"

  # ===== BUILD & PUSH DOCKER IMAGES =====
  build-and-push:
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    permissions:
      contents: read
      packages: write

    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4

      - name: 🏷️ Generate version tag
        id: version
        run: |
          SHORT_SHA=$(git rev-parse --short HEAD)
          echo "tag=v$(date +%Y.%m.%d)-${SHORT_SHA}" >> $GITHUB_OUTPUT

      - name: 🔐 Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: 🏗️ Build and push backend image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/backend:latest
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/backend:${{ steps.version.outputs.tag }}

      - name: 🏗️ Build and push frontend image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/frontend:latest
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/frontend:${{ steps.version.outputs.tag }}
          build-args: |
            NEXT_PUBLIC_API_URL=/api/v1

  # ===== DEPLOY A PRODUCCIÓN =====
  deploy:
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4

      - name: � Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.SERVER_IP }} >> ~/.ssh/known_hosts

      - name: 🔍 Debug SSH Key
        run: |
          echo "--- FINGERPRINT DE LA CLAVE ---"
          ssh-keygen -lf ~/.ssh/deploy_key
          echo "--- PRIMERAS 5 LÍNEAS DE LA CLAVE ---"
          head -5 ~/.ssh/deploy_key
          echo "--- ÚLTIMAS 5 LÍNEAS DE LA CLAVE ---"
          tail -5 ~/.ssh/deploy_key

      - name: 🧪 Test SSH Connection
        run: |
          echo "--- PROBANDO CONEXIÓN SSH CON DEBUG ---"
          ssh -vvv -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }} "echo '✅ SSH connection successful'" 2>&1 | tail -30

      - name: 🚀 Deploy to production server
        run: |
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }} << 'ENDSSH'
            cd /opt/import-app

            # Pull latest code
            echo "📥 Pulling latest code..."
            git pull origin main

            # Ensure correct DATABASE_URL format (asyncpg for async operations)
            echo "🔧 Verificando DATABASE_URL..."
            if ! grep -q "postgresql+asyncpg://" .env.production; then
              echo "⚠️ Corrigiendo DATABASE_URL a postgresql+asyncpg..."
              sed -i 's|DATABASE_URL=postgresql://|DATABASE_URL=postgresql+asyncpg://|' .env.production
            fi
            if grep -q "@db:" .env.production; then
              echo "⚠️ Corrigiendo hostname de db a postgres..."
              sed -i 's|@db:|@postgres:|' .env.production
            fi

            # Rebuild and restart services (rebuild if requirements changed)
            echo "🔨 Rebuilding and restarting services..."
            docker compose -f docker-compose.prod.yml up -d --build backend celery-worker celery-beat flower

            # Restart frontend if needed
            docker compose -f docker-compose.prod.yml up -d frontend

            # Clean up old images
            echo "🧹 Cleaning up old images..."
            docker image prune -f

            # Show status
            echo ""
            echo "📊 Estado de servicios:"
            docker compose -f docker-compose.prod.yml ps

            echo "✅ Deployment completed successfully"
          ENDSSH

      - name: 🔔 Notify deployment status
        if: always()
        run: |
          echo "Deployment status: ${{ job.status }}"
          # Aquí puedes agregar notificaciones a Slack, Discord, etc.

  # ===== CLEANUP =====
  cleanup:
    runs-on: ubuntu-latest
    needs: deploy
    if: always()

    steps:
      - name: 🧹 Clean up old images
        run: echo "Cleanup completed"
