name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # ===== LINT Y TESTS =====
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ['3.11']
        node-version: ['20']

    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4

      # Backend tests
      - name: ðŸ Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: ðŸ“¦ Install Python dependencies
        run: |
          cd backend
          pip install -r requirements.txt
          pip install pytest pytest-asyncio

      - name: ðŸ§ª Run Python tests
        run: |
          cd backend
          pytest -v || echo "Tests not implemented yet"

      # Frontend tests
      - name: ðŸ“¦ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}

      - name: ðŸ“¦ Install Node dependencies
        run: |
          cd frontend
          npm ci || npm install

      - name: ðŸ§ª Run Node tests
        run: |
          cd frontend
          npm test || echo "Tests not implemented yet"

  # ===== BUILD & PUSH DOCKER IMAGES =====
  build-and-push:
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    permissions:
      contents: read
      packages: write

    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ðŸ·ï¸ Generate version tag
        id: version
        run: |
          SHORT_SHA=$(git rev-parse --short HEAD)
          echo "tag=v$(date +%Y.%m.%d)-${SHORT_SHA}" >> $GITHUB_OUTPUT

      - name: ðŸ” Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: ðŸ—ï¸ Build and push backend image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/backend:latest
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/backend:${{ steps.version.outputs.tag }}

      - name: ðŸ—ï¸ Build and push frontend image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/frontend:latest
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/frontend:${{ steps.version.outputs.tag }}
          build-args: |
            NEXT_PUBLIC_API_URL=/api/v1

  # ===== DEPLOY A PRODUCCIÃ“N =====
  deploy:
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ï¿½ Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.SERVER_IP }} >> ~/.ssh/known_hosts

      - name: ðŸ” Debug SSH Key
        run: |
          echo "--- FINGERPRINT DE LA CLAVE ---"
          ssh-keygen -lf ~/.ssh/deploy_key
          echo "--- PRIMERAS 5 LÃNEAS DE LA CLAVE ---"
          head -5 ~/.ssh/deploy_key
          echo "--- ÃšLTIMAS 5 LÃNEAS DE LA CLAVE ---"
          tail -5 ~/.ssh/deploy_key

      - name: ðŸ§ª Test SSH Connection
        run: |
          echo "--- PROBANDO CONEXIÃ“N SSH CON DEBUG ---"
          ssh -vvv -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }} "echo 'âœ… SSH connection successful'" 2>&1 | tail -30

      - name: ðŸš€ Deploy to production server
        run: |
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }} << 'ENDSSH'
            cd /opt/import-app

            # Pull latest code
            echo "ðŸ“¥ Pulling latest code..."
            git pull origin main

            # Ensure correct DATABASE_URL format (asyncpg for async operations)
            echo "ðŸ”§ Verificando DATABASE_URL..."
            if ! grep -q "postgresql+asyncpg://" .env.production; then
              echo "âš ï¸ Corrigiendo DATABASE_URL a postgresql+asyncpg..."
              sed -i 's|DATABASE_URL=postgresql://|DATABASE_URL=postgresql+asyncpg://|' .env.production
            fi
            if grep -q "@db:" .env.production; then
              echo "âš ï¸ Corrigiendo hostname de db a postgres..."
              sed -i 's|@db:|@postgres:|' .env.production
            fi

            # Rebuild and restart services (rebuild if requirements changed)
            echo "ðŸ”¨ Rebuilding and restarting services..."
            docker compose -f docker-compose.prod.yml up -d --build backend celery-worker celery-beat flower

            # Restart frontend if needed
            docker compose -f docker-compose.prod.yml up -d frontend

            # Clean up old images
            echo "ðŸ§¹ Cleaning up old images..."
            docker image prune -f

            # Show status
            echo ""
            echo "ðŸ“Š Estado de servicios:"
            docker compose -f docker-compose.prod.yml ps

            echo "âœ… Deployment completed successfully"
          ENDSSH

      - name: ðŸ”” Notify deployment status
        if: always()
        run: |
          echo "Deployment status: ${{ job.status }}"
          # AquÃ­ puedes agregar notificaciones a Slack, Discord, etc.

  # ===== CLEANUP =====
  cleanup:
    runs-on: ubuntu-latest
    needs: deploy
    if: always()

    steps:
      - name: ðŸ§¹ Clean up old images
        run: echo "Cleanup completed"
